Syntax for Supported Primitive Functions and Special Forms

Primitive Functions

syntax: (exit)

syntax: (gc) -> <vector-gc-statistics>
syntax: (system <string>) -> <fixnum-return-code>
syntax: (getargs) -> #(<string0> <string1> ... )
syntax: (gettime) -> (<fixnum-seconds> . <fixnum-nanoseconds>)

syntax: (history) -> #t
syntax: (add-history <sexpr>) -> #t
syntax: (clear-history) -> #t
syntax: (set-prompt <string>) -> #t

syntax: (transcript-on <str>) -> #t
syntax: (transcript-off) -> #t

syntax: (cons <car> <cdr>) -> <pair>
syntax: (car <pair>) -> <exp>
syntax: (cdr <pair>) -> <exp>
syntax: (set-car! <pair> <newcar>) -> <pair>
syntax: (set-cdr! <pair> <newcdr>) -> <pair>
syntax: (length <list>) -> <fixnum>

syntax: (cxxr <pair>) -> <exp>
syntax: (cxxxr <pair>) -> <exp>
syntax: (cxxxxr <pair>) -> <exp>

syntax: (list {<exp>}*) -> <list>
syntax: (list* {<exp>}*) -> <list>

syntax: (vector {<exp>}*)
syntax: (make-vector <size>)
syntax: (vector-length <vector>)
syntax: (vector-ref <vector> <index>)
syntax: (vector-set! <vector> <index> <value>)
syntax: (vector-fill! <vector> <value>) -> <vector>
syntax: (vector-copy! <dest> <dest-start> <src> [<src-start> <src-end>]) -> <dest>
syntax: (find-index <item> <vector> [<limit>])

syntax: (list->vector <list>) -> <vector>
syntax: (vector->list <vector>) -> <list>

syntax: (byte-vector {<exp>}*)
syntax: (make-byte-vector <size>)
syntax: (byte-vector-ref <vector> <index>)
syntax: (byte-vector-set! <vector> <index> <value>)
syntax: (byte-vector-length <byte-vector>)

syntax: (eq? <exp1> <exp2>) -> <boolean>
syntax: (eqv? <exp1> <exp2>) -> <boolean>
syntax: (equal? <exp1> <exp2>) -> <boolean>

syntax: (string->symbol <str>) -> <symbol>
syntax: (symbol->string <sym>) -> <str>
syntax: (gensym [<sym>|<str>|<fix>]) -> <symbol>
syntax: (symbol-value <sym-expr>) -> <exp>
syntax: (set-symbol-value! <sym-expr> <value>)
syntax: (symbol-plist <sym-expr>) -> <plist>
syntax: (set-symbol-plist! <sym-expr> <plist>)
syntax: (get <sym> <prop>) -> <exp>
syntax: (put <sym> <prop> <value>) -> <prop>

syntax: (read [<inport>]) -> <exp>
syntax: (print <sexpr> [<outport>]) -> #t
syntax: (write <sexpr> [<outport>]) -> #t
syntax: (display <sexpr> [<outport>]) -> #t
syntax: (newline [<outport>]) -> #t
syntax: (read-char [<inport>]) -> <char>
syntax: (write-char <sexpr> [<outport>]) -> #t

syntax: (the-environment) -> <env>
syntax: (procedure-environment <closure>) -> <env>
syntax: (environment-parent <env>) -> <env>
syntax: (environment-bindings <env>) -> (<pair1> <pair2> ...)

syntax: (open-input-file <str>) -> <port>
syntax: (open-output-file <str>) -> <port>
syntax: (open-append-file <str>) -> <port>
syntax: (open-update-file <str>) -> <port>
syntax: (close-port <port>) -> #t
syntax: (close-input-port <port>) -> #t
syntax: (close-output-port <port>) -> #t
syntax: (set-file-position <port> <pos>) -> #t
syntax: (get-file-position <port>)
syntax: (flush-output [<outport>]) -> #t
syntax: (open-input-string <str>) -> <stringport>
syntax: (open-output-string) -> <stringport>
syntax: (open-output-string <stringport>)

syntax: (not <exp>) -> <boolean>, etc.          
syntax: (bound? <exp>)
syntax: (null? <exp>)
syntax: (atom? <exp>)
syntax: (list? <exp>)
syntax: (number? <exp>)
syntax: (boolean? <exp>)
syntax: (pair? <exp>)
syntax: (symbol? <exp>)
syntax: (complex? <exp>)
syntax: (real? <exp>)
syntax: (rational? <exp>)
syntax: (integer? <exp>)
syntax: (char? <exp>)
syntax: (string? <exp>)
syntax: (vector? <exp>)
syntax: (byte-vector? <exp>)
syntax: (closure? <exp>)
syntax: (procedure? <exp>)
syntax: (environment? <exp>)
syntax: (port? <exp>)
syntax: (input-port? <exp>)
syntax: (output-port? <exp>)
syntax: (string-port? <exp>)
syntax: (input-string-port? <exp>)
syntax: (output-string-port? <exp>)
syntax: (eof-object? <exp>)
syntax: (default-object? <exp>)
syntax: (zero? <exp>)
syntax: (positive? <exp>)
syntax: (negative? <exp>)
syntax: (odd? <exp>)
syntax: (even? <exp>)
syntax: (exact? <exp>)
syntax: (inexact? <exp>)
syntax: (promise? <exp>)

syntax: (list->string <list-of-chars>) -> <string>
syntax: (string->list <string>) -> <list-of-chars>
syntax: (integer->string <fixnum>) -> <string>
syntax: (string->integer <string>) -> <fixnum>

syntax: (member <exp> <list>) -> <exp> | nil
syntax: (memv <exp> <list>) -> <exp> | nil
syntax: (memq <exp> <list>) -> <exp> | nil
syntax: (assoc <exp> <alist>) -> (<exp> . <value>) | nil
syntax: (assv <exp> <alist>) -> (<exp> . <value>) | nil
syntax: (assq <exp> <alist>) -> (<exp> . <value>) | nil

syntax: (append <list1> <list2> ... <listn>) -> <list>
syntax: (reverse <list>) -> <list>
syntax: (last-pair <list>) -> <pair> | nil
syntax: (list-tail <list> <n>) -> <list> | nil

syntax: (+ <number>...) -> <number>
syntax: (- <number>...) -> <number>
syntax: (* <number>...) -> <number>
syntax: (/ <number>...) -> <number>

syntax: (= <number>...) -> <number>
syntax: (< <number>...) -> <number>
syntax: (<= <number>...) -> <number>
syntax: (> <number>...) -> <number>
syntax: (>= <number>...) -> <number>

syntax: (truncate <number>) -> <fixnum>
syntax: (floor <number>) -> <fixnum>
syntax: (ceiling <number>) -> <fixnum>
syntax: (round <number>) -> <fixnum>
syntax: (1+ <number>) -> <fixnum>
syntax: (-1+ <number>) -> <fixnum>
syntax: (inc <number>) -> <fixnum>
syntax: (dec <number>) -> <fixnum>
syntax: (abs <number>) -> <fixnum>
syntax: (gcd <fixnum>...) -> <fixnum>
syntax: (random <fixnum>) -> <fixnum>
syntax: (quotient <fixnum>...) -> <fixnum>
syntax: (remainder <fixnum>...) -> <fixnum>
syntax: (min <number>...) -> <number>
syntax: (max <number>...) -> <number>
syntax: (logand <fixnum>...) -> <fixnum>
syntax: (logior <fixnum>...) -> <fixnum>
syntax: (logxor <fixnum>...) -> <fixnum>
syntax: (shift-right <fixnum> <fixnum>) -> <fixnum>
syntax: (shift-left <fixnum> <fixnum>) -> <fixnum>
syntax: (shift-right-arithmetic <fixnum> <fixnum>) -> <fixnum>

syntax: (string-null? <str>) -> <boolean>
syntax: (string-length <str>) -> <fixnum>
syntax: (string-append <s1> <s2> ... <sn>) -> <string>
syntax: (string-ref <s> <index>) -> <char>
syntax: (string-set! <s> <index> <ch>) -> <string>
syntax: (substring <s> <start> <end>) -> <string>
syntax: (string-fill! <s> <ch>) -> <string>
syntax: (string-copy! <dest> <dest-start> <src> [<src-start> <src-end>]) -> <dest>

syntax: (string=? <str> <str>)
syntax: (string<? <str> <str>)
syntax: (string<=? <str> <str>)
syntax: (string>? <str> <str>)
syntax: (string>=? <str> <str>)
syntax: (string-ci=? <str> <str>)
syntax: (string-ci<? <str> <str>)
syntax: (string-ci<=? <str> <str>)
syntax: (string-ci>? <str> <str>)
syntax: (string-ci>=? <str> <str>)

syntax: (char=? <char> <char>)
syntax: (char<? <char> <char>)
syntax: (char<=? <char> <char>)
syntax: (char>? <char> <char>)
syntax: (char>=? <char> <char>)
syntax: (char-ci=? <char> <char>)
syntax: (char-ci<? <char> <char>)
syntax: (char-ci<=? <char> <char>)
syntax: (char-ci>? <char> <char>)
syntax: (char-ci>=? <char> <char>)

syntax: (char-alphabetic? <char>) -> <boolean>
syntax: (char-numeric? <char>) -> <boolean>
syntax: (char-whitespace? <char>) -> <boolean>
syntax: (char-upper-case? <char>) -> <boolean>
syntax: (char-lower-case? <char>) -> <boolean>
syntax: (char-upcase <char>) -> <char>
syntax: (char-downcase <char>) -> <char>

syntax: (char->integer <char>) -> <fixnum>
syntax: (integer->char <integer>) -> <char>

syntax: (eval <exp> [<env>]) -> <exp-evaluated>
syntax: (apply <fn> <arglist>) -> <exp-fn-result>
syntax: (call/cc <fn>) -> <exp-fn-result>
syntax: (map <fn> <list>) -> <list-of-fn-results>
syntax: (foreach <fn> <list>) -> nil
syntax: (force <promise>) -> <promise-evaluated>

Special Forms

syntax: (begin <sequence>) -> <evaluated-tail-in-sequence>
syntax: (sequence <sequence>) -> <evaluated-tail-in-sequence>
syntax: (while <cond> <sequence>) -> #f
syntax: (set! <var> <exp>) -> <exp-evaluated>
syntax: (set! (access <var> <env>) <exp>) -> <exp-evaluated>
syntax: (access <symbol> <env>) -> <symbol-value>
syntax: (define <var> <exp>) -> <var>
syntax: (lambda <fargs> <sequence>) -> <closure>
syntax: (cond (<exp> <sequence>)...) -> #f | <evaluated-tail-in-sequence>
syntax: (if <expr> <then-exp> <else-exp>) -> <evaluated-tail-in-exp>
syntax: (and <sequence>) -> #t | <evaluated-exp-in-sequence>
syntax: (or <sequence>) -> #f | <non-false-evaluated-exp-in-sequence>
syntax: (let <bindings> <sequence>) ->  <evaluated-tail-in-sequence>
syntax: (letrec <bindings> <sequence>) -> <evaluated-tail-in-sequence>
syntax: (let* <bindings> <sequence>) -> <evaluated-tail-in-sequence>

Escheme Custom Functions

syntax: (%make-environment <pairs> <baseenv>) -> <env>
syntax: (%make-closure <code> <params> <env>) -> <closure>
syntax: (%parse-formals <params>) -> <vector>
syntax: (%gref <symbol>) -> <gref>
syntax: (%fref <depth> <index>) -> <fref>
syntax: (%closure-code <closure>) -> <list>
syntax: (%closure-benv <closure>) -> <env>
syntax: (%closure-vars <closure>) -> <list>
syntax: (%closure-numv <closure>) -> <fixnum>
syntax: (%closure-rest <closure>) -> <boolean>

Compiled Escheme

syntax: (code? <exp>)
syntax: (compile <exp> [<env>]) -> <code>
syntax: (%closure-code <closure>) -> <code>



